First-time SSH experiment
=========================

The goal of today's exercise simple: make an executable that will
take two arguments: device to run the command on, the command to run,
and to return the result of this command.

To make the examples easy to follow, I will be using lxd containers,
and doing the work inside them. 

First we start up the container and jump into the shell there:

```
ayourtch@ayourtch-x280:~$ lxc launch ubuntu:18.04 ts-netops
Creating ts-netops
Starting ts-netops                          
ayourtch@ayourtch-x280:~$ lxc exec ts-netops -- su -l ubuntu
To run a command as administrator (user "root"), use "sudo <command>".
See "man sudo_root" for details.

ubuntu@ts-netops:~$ 
```

Now let's prepare the prerequisites. First let's check that the SSH
is working:

```
ubuntu@ts-netops:~$ ssh ay@003-X03-S0457.lan
The authenticity of host '003-x03-s0457.lan (192.168.42.167)' can't be established.
RSA key fingerprint is SHA256:w67xobXulINID8cDDU9/vkB4mNb2IzwutfHE2ZEqg3A.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '003-x03-s0457.lan,192.168.42.167' (RSA) to the list of known hosts.
C
##############################################################
##               Hostname: 003-X03-S0457                    ##
##                                                          ##
##          UNAUTHORIZED ACCESS IS PROHIBITED               ##
##                                                          ##
##     All sessions to this device are being monitored.     ##
##     If unauthorized access is detected, your address     ##
##     will be logged and the authorities will be           ##
##     notified to take appropriate actions.                ## 
##                                                          ##
##                                                          ##
##############################################################
Password: 
003-X03-S0457#
```


Notice that I am using the DNS. It is 2020, and even on my small
home network that uses OpenWRT (I mean LEDE :) the DNS zone .lan
is automatically populated from the DHCP server.

If your network does not do that - you have some homework to do :)
Because we will need the DNS as well.

In any case, you noticed that I have dropped directly into privileged
mode, so it's time to share my AAA configuration:

```
003-X03-S0457#sh run aaa 
Load for five secs: 22%/0%; one minute: 23%; five minutes: 23%
Time source is NTP, 21:08:11.568 CET Tue Jul 6 1915
!
aaa authentication login default group ACS local
aaa authentication login CONSOLE local
aaa authentication enable default group ACS enable
aaa authorization exec default group ACS local 
username ay privilege 15 password cisco123
!
!
aaa group server tacacs+ ACS
 server-private 10.100.253.7 key not-the-real-key 
 server-private 10.100.253.107 key not-the-real-key
 ip tacacs source-interface Loopback0
!
!
aaa new-model
aaa session-id common
!
!
          
003-X03-S0457#

003-X03-S0457#show ver
Load for five secs: 22%/0%; one minute: 22%; five minutes: 23%
Time source is NTP, 21:13:53.655 CET Tue Jul 6 1915
Cisco IOS Software, C3560CX Software (C3560CX-UNIVERSALK9-M), Version 15.2(4)E5, RELEASE SOFTWARE (fc2)
Technical Support: http://www.cisco.com/techsupport
Copyright (c) 1986-2017 by Cisco Systems, Inc.
Compiled Mon 18-Sep-17 08:28 by prod_rel_team

....

003-X03-S0457#show run | section include line 
line con 0
 exec-timeout 180 0
 privilege level 15
 logging synchronous
 login authentication CONSOLE
line vty 0
 access-class MGMT in
 exec-timeout 0 0
 privilege level 15
 ipv6 access-class IPv6_MGMT in
 logging synchronous
 exec prompt timestamp
 transport input telnet ssh
 transport output telnet ssh
line vty 1 4
 access-class MGMT in
 privilege level 15
 ipv6 access-class IPv6_MGMT in
 logging synchronous
 exec prompt timestamp
 transport input telnet ssh
 transport output telnet ssh
line vty 5 15
 access-class MGMT in
 privilege level 15
....
```

This switch in fact does not have the AAA server in its vicinity now - 
so you will see that the "Password:" prompt starts with the capital letter,
signifying the local authentication, and it does take a while to
both get to the password prompt as well as to the exec prompt itself.

When coding, I try to imagine the possible failure modes that may happen,
and try to make them normal and regularly tested as part of the development.
The missing/"failed" AAA server is one of these tricks. This approach allows
to catch significantly more issues during the early stages, rather than
during the production time.

Anyway, this is about all we needed from the switch side, so let's return to our
prompt and get going with coding...

```
003-X03-S0457#q
Connection to 003-x03-s0457.lan closed by remote host.
Connection to 003-x03-s0457.lan closed.
ubuntu@ts-netops:~$ 
ubuntu@ts-netops:~$ 
```

First of all, we will need to install Rust (Remember, it is a fresh container).

you can go to https://rustup.rs directly, but searching for
"how to install rust" usually also brings us there, so we get the following bit of code to run:

```
ubuntu@ts-netops:~$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust
programming language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to
Cargo's bin directory, located at:

  /home/ubuntu/.cargo/bin

This can be modified with the CARGO_HOME environment variable.

Rustup metadata and toolchains will be installed into the Rustup
home directory, located at:

  /home/ubuntu/.rustup

This can be modified with the RUSTUP_HOME environment variable.

This path will then be added to your PATH environment variable by
modifying the profile file located at:

  /home/ubuntu/.profile

You can uninstall at any time with rustup self uninstall and
these changes will be reverted.

Current installation options:


   default host triple: x86_64-unknown-linux-gnu
     default toolchain: stable
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>
```

Hit "1", press "ENTER" and in a minute or so you will see:


```
>1

info: profile set to 'default'
info: default host triple is x86_64-unknown-linux-gnu
info: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'
info: latest update on 2020-05-07, rust version 1.43.1 (8d69840ab 2020-05-04)
info: downloading component 'cargo'
info: downloading component 'clippy'
info: downloading component 'rust-docs'
 12.1 MiB /  12.1 MiB (100 %)   4.5 MiB/s in  2s ETA:  0s
info: downloading component 'rust-std'
 17.5 MiB /  17.5 MiB (100 %)   5.7 MiB/s in  3s ETA:  0s
info: downloading component 'rustc'
 60.0 MiB /  60.0 MiB (100 %)   6.8 MiB/s in  8s ETA:  0s
info: downloading component 'rustfmt'
info: installing component 'cargo'
info: installing component 'clippy'
info: installing component 'rust-docs'
 12.1 MiB /  12.1 MiB (100 %)   8.6 MiB/s in  1s ETA:  0s
info: installing component 'rust-std'
 17.5 MiB /  17.5 MiB (100 %)  14.6 MiB/s in  1s ETA:  0s
info: installing component 'rustc'
 60.0 MiB /  60.0 MiB (100 %)  11.7 MiB/s in  5s ETA:  0s
info: installing component 'rustfmt'
info: default toolchain set to 'stable'

  stable installed - rustc 1.43.1 (8d69840ab 2020-05-04)


Rust is installed now. Great!

To get started you need Cargo's bin directory ($HOME/.cargo/bin) in your PATH
environment variable. Next time you log in this will be done
automatically.

To configure your current shell run source $HOME/.cargo/env
ubuntu@ts-netops:~$ 

```

Doing "source ..." is useful to get all the changes that the installation
adds, without logging out and back in.

Let's create our application:

```
ubuntu@ts-netops:~$ cargo new --bin ts-netops-simple-ssh
     Created binary (application) `ts-netops-simple-ssh` package
ubuntu@ts-netops:~$
ubuntu@ts-netops:~$ cd ts-netops-simple-ssh/
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)

error: aborting due to previous error

error: could not compile `ts-netops-simple-ssh`.

To learn more, run the command again with --verbose.
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Oops. Looks like we need some prerequisites.

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ sudo apt-get update; sudo apt-get -y install git build-essential
Hit:1 http://archive.ubuntu.com/ubuntu bionic InRelease
.... lots of irrelevant scrolling skipped ....

ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 

What did this get us ?

ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 
Hello, world!
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 

Note, that you can also do "cargo run":

ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/ts-netops-simple-ssh`
Hello, world!
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

I personally prefer "cargo build", because then the motor memory is the same
if I later switch to using Makefiles.

In any case, before we go further, let's take a look at what we have:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ls -al
total 32
drwxrwxr-x 5 ubuntu ubuntu 4096 May 15 19:06 .
drwxr-xr-x 7 ubuntu ubuntu 4096 May 15 19:07 ..
drwxrwxr-x 6 ubuntu ubuntu 4096 May 15 19:06 .git
-rw-rw-r-- 1 ubuntu ubuntu    8 May 15 19:06 .gitignore
-rw-rw-r-- 1 ubuntu ubuntu  151 May 15 19:06 Cargo.lock
-rw-rw-r-- 1 ubuntu ubuntu  210 May 15 19:06 Cargo.toml
drwxrwxr-x 2 ubuntu ubuntu 4096 May 15 19:06 src
drwxrwxr-x 3 ubuntu ubuntu 4096 May 15 19:06 target
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Notice that cargo helpfully created a git repository, and the presence of two
directories: "src" and "target" - the first one holds the source, the second
is where the compilation results appear.

There are two very interesting files - Cargo.toml and Cargo.lock:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cat Cargo.toml 
[package]
name = "ts-netops-simple-ssh"
version = "0.1.0"
authors = ["ubuntu"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cat Cargo.lock 
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
[[package]]
name = "ts-netops-simple-ssh"
version = "0.1.0"
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```


The first one is the file where you will specify your dependencies,
the external modules in Rust are called "crates".

The second file is the "version lock" file - when a new dependency
is added to Cargo.toml, the Cargo.lock is populated with its exact
version as well as with the exact versions of the downstream dependencies.

So, if you want your executable project to consistently build,
rather than always attempt to use "latest" - check in the Cargo.lock
file.

Let's make our first commit, while we are at it:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git add src/ Cargo.*
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "Initial commit"
[master (root-commit) c8e6570] Initial commit
 Committer: Ubuntu <ubuntu@ts-netops.lxd>
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 3 files changed, 17 insertions(+)
 create mode 100644 Cargo.lock
 create mode 100644 Cargo.toml
 create mode 100644 src/main.rs
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git config --global user.name "Andrew Yourtchenko"
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git config --global user.email "ayourtch@gmail.com"
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit --amend --reset-author --no-edit
[master 9615368] Initial commit
 3 files changed, 17 insertions(+)
 create mode 100644 Cargo.lock
 create mode 100644 Cargo.toml
 create mode 100644 src/main.rs
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

We are ready to finally start coding! 

Let's add the ssh2 library to Cargo.toml:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/Cargo.toml b/Cargo.toml
index ad852ba..904dd75 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -7,3 +7,4 @@ edition = "2018"
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
+ssh2 = "0.8"
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "Add ssh2 to Cargo.toml"
[master b031d37] Add ssh2 to Cargo.toml
 1 file changed, 1 insertion(+)
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

You will notice that I commit very frequently - this makes it much easier
to track down what happened, as well as roll back if needed. In real
world the small and granular commits help as well.

Now let's run "cargo build" again:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
    Updating crates.io index
  Downloaded ssh2 v0.8.1
  Downloaded libc v0.2.70
  Downloaded parking_lot v0.10.2
  Downloaded bitflags v1.2.1
  Downloaded libssh2-sys v0.2.17
  Downloaded lock_api v0.3.4
  Downloaded parking_lot_core v0.7.2
  Downloaded cc v1.0.53
  Downloaded scopeguard v1.1.0
  Downloaded openssl-sys v0.9.56
  Downloaded libz-sys v1.0.25
  Downloaded smallvec v1.4.0
  Downloaded pkg-config v0.3.17
  Downloaded cfg-if v0.1.10
  Downloaded autocfg v1.0.0
   Compiling cc v1.0.53
   Compiling pkg-config v0.3.17
   Compiling libc v0.2.70
   Compiling autocfg v1.0.0
   Compiling cfg-if v0.1.10
   Compiling bitflags v1.2.1
   Compiling scopeguard v1.1.0
   Compiling smallvec v1.4.0
   Compiling lock_api v0.3.4
   Compiling openssl-sys v0.9.56
   Compiling libz-sys v1.0.25
   Compiling libssh2-sys v0.2.17
   Compiling parking_lot_core v0.7.2
   Compiling parking_lot v0.10.2
error: failed to run custom build command for `openssl-sys v0.9.56`

Caused by:
  process didn't exit successfully: `/home/ubuntu/ts-netops-simple-ssh/target/debug/build/openssl-sys-ea8ad3890cb6a4c9/build-script-main` (exit code: 101)
--- stdout
cargo:rustc-cfg=const_fn
cargo:rerun-if-env-changed=X86_64_UNKNOWN_LINUX_GNU_OPENSSL_LIB_DIR
X86_64_UNKNOWN_LINUX_GNU_OPENSSL_LIB_DIR unset
cargo:rerun-if-env-changed=OPENSSL_LIB_DIR
OPENSSL_LIB_DIR unset
cargo:rerun-if-env-changed=X86_64_UNKNOWN_LINUX_GNU_OPENSSL_INCLUDE_DIR
X86_64_UNKNOWN_LINUX_GNU_OPENSSL_INCLUDE_DIR unset
cargo:rerun-if-env-changed=OPENSSL_INCLUDE_DIR
OPENSSL_INCLUDE_DIR unset
cargo:rerun-if-env-changed=X86_64_UNKNOWN_LINUX_GNU_OPENSSL_DIR
X86_64_UNKNOWN_LINUX_GNU_OPENSSL_DIR unset
cargo:rerun-if-env-changed=OPENSSL_DIR
OPENSSL_DIR unset
run pkg_config fail: "Failed to run `\"pkg-config\" \"--libs\" \"--cflags\" \"openssl\"`: No such file or directory (os error 2)"

--- stderr
thread 'main' panicked at '

Could not find directory of OpenSSL installation, and this `-sys` crate cannot
proceed without this knowledge. If OpenSSL is installed and this crate had
trouble finding it,  you can set the `OPENSSL_DIR` environment variable for the
compilation process.

Make sure you also have the development packages of openssl installed.
For example, `libssl-dev` on Ubuntu or `openssl-devel` on Fedora.

If you're in a situation where you think the directory *should* be found
automatically, please open a bug at https://github.com/sfackler/rust-openssl
and include information about your system as well as this message.

$HOST = x86_64-unknown-linux-gnu
$TARGET = x86_64-unknown-linux-gnu
openssl-sys = 0.9.56


It looks like you're compiling on Linux and also targeting Linux. Currently this
requires the `pkg-config` utility to find OpenSSL but unfortunately `pkg-config`
could not be found. If you have OpenSSL installed you can likely fix this by
installing `pkg-config`.

', /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/openssl-sys-0.9.56/build/find_normal.rs:155:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

warning: build failed, waiting for other jobs to finish...
error: build failed
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Oops, seems like we need some more dependencies, so let's do as instructed:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ sudo apt-get -y install pkg-config libssl-dev
Reading package lists... Done
.....
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling openssl-sys v0.9.56
   Compiling libssh2-sys v0.2.17
   Compiling ssh2 v0.8.1
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
    Finished dev [unoptimized + debuginfo] target(s) in 4.22s
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

All right, this is much better. Let's doublecheck if anything changed:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/Cargo.lock b/Cargo.lock
index 4eb1871..83c5025 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1,5 +1,183 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
+[[package]]
+name = "autocfg"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d"
+
+[[package]]
+name = "bitflags"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"
+
+[[package]]

..... Many more lines .....

```

Ahha! As I mentioned earlier - "cargo build" caused the exact versions of the ssh library to be pinned down.

Let's commit it:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "After the cargo build run"
[master e089fe7] After the cargo build run
 1 file changed, 178 insertions(+)
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Now, what do we do with this library ?

Let's go to crates.rs website, which redirects us to lib.rs - and search
for "ssh2", or go just to https://lib.rs/search?q=ssh2 and go to the crate
page - there is a link "Documentation" which sends us to https://docs.rs/ssh2/0.8.1/ssh2/

Scrolling the documentation page, we find almost exactly what we need:
"Running a command":

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index e7a11a9..e4ddfcc 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,3 +1,20 @@
 fn main() {
-    println!("Hello, world!");
+    use std::io::prelude::*;
+use std::net::{TcpStream};
+use ssh2::Session;
+
+// Connect to the local SSH server
+let tcp = TcpStream::connect("127.0.0.1:22").unwrap();
+let mut sess = Session::new().unwrap();
+sess.set_tcp_stream(tcp);
+sess.handshake().unwrap();
+sess.userauth_agent("username").unwrap();
+
+let mut channel = sess.channel_session().unwrap();
+channel.exec("ls").unwrap();
+let mut s = String::new();
+channel.read_to_string(&mut s).unwrap();
+println!("{}", s);
+channel.wait_close();
+println!("{}", channel.exit_status().unwrap());
 }
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

You will notice that my formatting is off... We can fix it easily, by running
cargo fmt:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo fmt
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index e7a11a9..32a74f5 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,3 +1,20 @@
 fn main() {
-    println!("Hello, world!");
+    use ssh2::Session;
+    use std::io::prelude::*;
+    use std::net::TcpStream;
+
+    // Connect to the local SSH server
+    let tcp = TcpStream::connect("127.0.0.1:22").unwrap();
+    let mut sess = Session::new().unwrap();
+    sess.set_tcp_stream(tcp);
+    sess.handshake().unwrap();
+    sess.userauth_agent("username").unwrap();
+
+    let mut channel = sess.channel_session().unwrap();
+    channel.exec("ls").unwrap();
+    let mut s = String::new();
+    channel.read_to_string(&mut s).unwrap();
+    println!("{}", s);
+    channel.wait_close();
+    println!("{}", channel.exit_status().unwrap());
 }
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Let's give it a go:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
warning: unused `std::result::Result` that must be used
  --> src/main.rs:18:5
   |
18 |     channel.wait_close();
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

This is a warning, to which we return later, but it built the executable.
Let's run it:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error { code: -39, msg: "no auth sock variable" }', src/main.rs:11:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

This seems more serious. Let's check what is going on:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cat -n src/main.rs 
     1	fn main() {
     2	    use ssh2::Session;
     3	    use std::io::prelude::*;
     4	    use std::net::TcpStream;
     5	
     6	    // Connect to the local SSH server
     7	    let tcp = TcpStream::connect("127.0.0.1:22").unwrap();
     8	    let mut sess = Session::new().unwrap();
     9	    sess.set_tcp_stream(tcp);
    10	    sess.handshake().unwrap();
    11	    sess.userauth_agent("username").unwrap();
    12	
    13	    let mut channel = sess.channel_session().unwrap();
    14	    channel.exec("ls").unwrap();
    15	    let mut s = String::new();
    16	    channel.read_to_string(&mut s).unwrap();
    17	    println!("{}", s);
    18	    channel.wait_close();
    19	    println!("{}", channel.exit_status().unwrap());
    20	}
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Well, obviously before running the copy-pasted code every person *should*
read it and understand, but I wanted to really show the error-message-driven
programming.

So we have sess.userauth_agent("username").unwrap(); - what's going on?

The unwrap() is a function that works on so-called "enum types" - the
ones that encapsulate the content. if the unwrapping fails - the program
fails in a controlled fashion. else you get the result.

userauth_agent() is returning an error.

Let's read the manual at https://docs.rs/ssh2/0.8.1/ssh2/struct.Session.html

"This is a helper method for attempting to authenticate the current connection with the first public key found in an SSH agent. If more control is needed than this method offers, it is recommended to use agent directly to control how the identity is found."

This is cool, but not what we need - we need a different function:
https://docs.rs/ssh2/0.8.1/ssh2/struct.Session.html#method.userauth_password


Let's use that and hardcode the credentials for now:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index 32a74f5..e4df0c7 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -8,7 +8,7 @@ fn main() {
     let mut sess = Session::new().unwrap();
     sess.set_tcp_stream(tcp);
     sess.handshake().unwrap();
-    sess.userauth_agent("username").unwrap();
+    sess.userauth_password("ay", "cisco123").unwrap();
 
     let mut channel = sess.channel_session().unwrap();
     channel.exec("ls").unwrap();
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
warning: unused `std::result::Result` that must be used
  --> src/main.rs:18:5
   |
18 |     channel.wait_close();
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error { code: -18, msg: "Authentication failed (username/password)" }', src/main.rs:11:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "Use password authentication"
[master 13cfbb9] Use password authentication
 1 file changed, 1 insertion(+), 1 deletion(-)
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Wait. Pause. Hardcoding credentials is a VERY BAD idea. Committing them
to a repository is VERY VERY BAD idea. If I push the the repository now
elsewhere, the credentials will end up going completely outside of my control.

Let's fix that:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git reset HEAD~1
Unstaged changes after reset:
M	src/main.rs
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "Use password authentication"^C
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index 32a74f5..e4df0c7 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -8,7 +8,7 @@ fn main() {
     let mut sess = Session::new().unwrap();
     sess.set_tcp_stream(tcp);
     sess.handshake().unwrap();
-    sess.userauth_agent("username").unwrap();
+    sess.userauth_password("ay", "cisco123").unwrap();
 
     let mut channel = sess.channel_session().unwrap();
     channel.exec("ls").unwrap();
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

If you do git log now, you notice we got rid of the erroneous change:
(Disclaimer: I can not guarantee the object itself disappeared the repository, but at least this removes
the smoking gun. In any case, out of abundance of caution it is always good to treat this kind of case as a compromised password, and change it. This is why you never ever ever hardcode the passwords)

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git log
commit 61e12d2c99b4653be31592246833aa92d720ecd2 (HEAD -> master)
Author: Andrew Yourtchenko <ayourtch@gmail.com>
Date:   Fri May 15 19:39:09 2020 +0000

    A copy-paste from ssh2 docs

commit e089fe74ae7e8090deb8f137b0150ffa04a85b11
Author: Andrew Yourtchenko <ayourtch@gmail.com>
Date:   Fri May 15 19:31:58 2020 +0000
```

Let's take the credentials from two environment variables:

TS_NETOPS_USER and TS_NETOPS_PASS

Searching for "rust get environment variable" gives us:


To set its value, we call the env::var function and pass it the name of the CASE_INSENSITIVE environment variable. The env::var function returns a Result that will be the successful Ok variant that contains the value of the environment variable if the environment variable is set.

env is the standard crate, so we do not need to edit Cargo.toml.

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index 32a74f5..42622ea 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -8,7 +8,9 @@ fn main() {
     let mut sess = Session::new().unwrap();
     sess.set_tcp_stream(tcp);
     sess.handshake().unwrap();
-    sess.userauth_agent("username").unwrap();
+    let ts_netops_user = std::env::var("TS_NETOPS_USER").unwrap();
+    let ts_netops_pass = std::env::var("TS_NETOPS_PASS").unwrap();
+    sess.userauth_password(ts_netops_user, ts_netops_pass).unwrap();
 
     let mut channel = sess.channel_session().unwrap();
     channel.exec("ls").unwrap();
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
error[E0308]: mismatched types
  --> src/main.rs:13:28
   |
13 |     sess.userauth_password(ts_netops_user, ts_netops_pass).unwrap();
   |                            ^^^^^^^^^^^^^^
   |                            |
   |                            expected `&str`, found struct `std::string::String`
   |                            help: consider borrowing here: `&ts_netops_user`

error[E0308]: mismatched types
  --> src/main.rs:13:44
   |
13 |     sess.userauth_password(ts_netops_user, ts_netops_pass).unwrap();
   |                                            ^^^^^^^^^^^^^^
   |                                            |
   |                                            expected `&str`, found struct `std::string::String`
   |                                            help: consider borrowing here: `&ts_netops_pass`

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0308`.
error: could not compile `ts-netops-simple-ssh`.

To learn more, run the command again with --verbose.
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Let's follow what the error messages say...

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index 32a74f5..485eaaf 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -8,7 +8,9 @@ fn main() {
     let mut sess = Session::new().unwrap();
     sess.set_tcp_stream(tcp);
     sess.handshake().unwrap();
-    sess.userauth_agent("username").unwrap();
+    let ts_netops_user = std::env::var("TS_NETOPS_USER").unwrap();
+    let ts_netops_pass = std::env::var("TS_NETOPS_PASS").unwrap();
+    sess.userauth_password(&ts_netops_user, &ts_netops_pass).unwrap();
 
     let mut channel = sess.channel_session().unwrap();
     channel.exec("ls").unwrap();
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
warning: unused `std::result::Result` that must be used
  --> src/main.rs:20:5
   |
20 |     channel.wait_close();
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "Use environment variables for user/pass rather than userauth agent" 
[master efed2f8] Use environment variables for user/pass rather than userauth agent
 1 file changed, 3 insertions(+), 1 deletion(-)
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```


Better! Let's run it:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: NotPresent', src/main.rs:11:26
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cat -n src/main.rs 
     1	fn main() {
     2	    use ssh2::Session;
     3	    use std::io::prelude::*;
     4	    use std::net::TcpStream;
     5	
     6	    // Connect to the local SSH server
     7	    let tcp = TcpStream::connect("127.0.0.1:22").unwrap();
     8	    let mut sess = Session::new().unwrap();
     9	    sess.set_tcp_stream(tcp);
    10	    sess.handshake().unwrap();
    11	    let ts_netops_user = std::env::var("TS_NETOPS_USER").unwrap();
    12	    let ts_netops_pass = std::env::var("TS_NETOPS_PASS").unwrap();
    13	    sess.userauth_password(&ts_netops_user, &ts_netops_pass).unwrap();
    14	
    15	    let mut channel = sess.channel_session().unwrap();
    16	    channel.exec("ls").unwrap();
    17	    let mut s = String::new();
    18	    channel.read_to_string(&mut s).unwrap();
    19	    println!("{}", s);
    20	    channel.wait_close();
    21	    println!("{}", channel.exit_status().unwrap());
    22	}
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Cool. We forgot to set the variable, and instead of attempting to run
with a null username or empty username or uninitialized data, the unwrap()
method points us precisely to where the problem is.

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ export TS_NETOPS_USER=ay
ubuntu@ts-netops:~/ts-netops-simple-ssh$ export TS_NETOPS_PASS=anotherpassword
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error { code: -18, msg: "Authentication failed (username/password)" }', src/main.rs:13:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
ubuntu@ts-netops:~/ts-netops-simple-ssh$
```

This makes sense - we are attempting to authenticate to a local host rather than to the target...
Let's use the environment variable for the target as well:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index 485eaaf..e5dc6c0 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -4,7 +4,9 @@ fn main() {
     use std::net::TcpStream;
 
     // Connect to the local SSH server
-    let tcp = TcpStream::connect("127.0.0.1:22").unwrap();
+    let ts_netops_host = std::env::var("TS_NETOPS_HOST").unwrap();
+    let tcp_target = format!("{}:22", ts_netops_host);
+    let tcp = TcpStream::connect(tcp_target).unwrap();
     let mut sess = Session::new().unwrap();
     sess.set_tcp_stream(tcp);
     sess.handshake().unwrap();
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
warning: unused `std::result::Result` that must be used
  --> src/main.rs:22:5
   |
22 |     channel.wait_close();
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "Use TS_NETOPS_HOST instead of fixed target"
[master 09b4278] Use TS_NETOPS_HOST instead of fixed target
 1 file changed, 3 insertions(+), 1 deletion(-)
ubuntu@ts-netops:~/ts-netops-simple-ssh$ export TS_NETOPS_HOST=003-X03-S0457.lan
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Custom { kind: Other, error: "transport read" }', src/main.rs:20:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Oops.. Something bad happened... Let's retry...

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 

Line has invalid autocommand "ls"
0
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Doing a little bit of debugging gives us the hint that there is something possibly in the way the two ends interoperate, and it is our client end closing the connection. Possibly something between the TCP and libssh2 ?

Let's give a shot to a little retry mechanism:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index e5dc6c0..a84903b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -17,7 +17,13 @@ fn main() {
     let mut channel = sess.channel_session().unwrap();
     channel.exec("ls").unwrap();
     let mut s = String::new();
-    channel.read_to_string(&mut s).unwrap();
+    let mut result = channel.read_to_string(&mut s);
+    let mut retry_count = 10;
+    while result.is_err() && retry_count > 0 {
+        retry_count = retry_count - 1;
+        eprintln!("Retry. Remaining: {}", retry_count);
+        result = channel.read_to_string(&mut s);
+    }
     println!("{}", s);
     channel.wait_close();
     println!("{}", channel.exit_status().unwrap());
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "Add a retry mechanism"
[master ae50f21] Add a retry mechanism
 1 file changed, 7 insertions(+), 1 deletion(-)
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
warning: unused `std::result::Result` that must be used
  --> src/main.rs:28:5
   |
28 |     channel.wait_close();
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 
Retry. Remaining: 9

Line has invalid autocommand "ls"
0
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 
Retry. Remaining: 9

Line has invalid autocommand "ls"
0
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh 

Line has invalid autocommand "ls"
0
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Perfect. We now can fairly reliably retrieve something.
Now, let's change this to an actual command.
This time let's use the command-line argument.

Searching for "rust argv" gives us the function std::env::args() - which
returns a type Args: https://doc.rust-lang.org/stable/std/env/struct.Args.html
we can browse the traits of this type, and in the Iterator trait we can find the
function nth() which we will use:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index a84903b..fcdc1a1 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -3,6 +3,7 @@ fn main() {
     use std::io::prelude::*;
     use std::net::TcpStream;
 
+    let command_to_run = std::env::args().nth(1).unwrap();
     // Connect to the local SSH server
     let ts_netops_host = std::env::var("TS_NETOPS_HOST").unwrap();
     let tcp_target = format!("{}:22", ts_netops_host);
@@ -15,7 +16,7 @@ fn main() {
     sess.userauth_password(&ts_netops_user, &ts_netops_pass).unwrap();
 
     let mut channel = sess.channel_session().unwrap();
-    channel.exec("ls").unwrap();
+    channel.exec(&command_to_run).unwrap();
     let mut s = String::new();
     let mut result = channel.read_to_string(&mut s);
     let mut retry_count = 10;
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "take the command to execute from CLI"
[master d66586f] take the command to execute from CLI
 1 file changed, 2 insertions(+), 1 deletion(-)
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh "who"
Retry. Remaining: 9

    Line       User       Host(s)              Idle       Location
   1 vty 0     ay         idle                 00:01:35 192.168.42.111
*  2 vty 1     ay         idle                 00:00:20 192.168.42.209

  Interface    User               Mode         Idle     Peer Address

0
ubuntu@ts-netops:~/ts-netops-simple-ssh$ ./target/debug/ts-netops-simple-ssh "show ip int brie"
Load for five secs: 21%/0%; one minute: 22%; five minutes: 22%
Time source is NTP, 00:15:58.981 CET Wed Jul 7 1915

Interface              IP-Address      OK? Method Status                Protocol
Vlan1                  unassigned      YES NVRAM  administratively down down    
Vlan2                  10.2.3.254      YES NVRAM  up                    down    
Vlan3                  37.34.67.254    YES NVRAM  up                    down    
Vlan7                  10.7.3.254      YES NVRAM  up                    down    
Vlan16                 10.16.3.254     YES NVRAM  up                    down    
Vlan17                 10.17.3.254     YES NVRAM  up                    down    
Vlan18                 10.18.3.254     YES NVRAM  up                    down    
Vlan19                 10.19.3.254     YES NVRAM  up                    down    
Vlan20                 10.20.3.254     YES NVRAM  up                    down    
Vlan21                 10.21.3.254     YES NVRAM  up                    down    
Vlan22                 10.22.3.254     YES NVRAM  up                    down    
Vlan23                 10.23.3.254     YES NVRAM  up                    down    
Vlan24                 10.24.3.254     YES NVRAM  up                    down    
Vlan25                 10.25.3.254     YES NVRAM  up                    down    
Vlan26                 10.26.3.254     YES NVRAM  up                    down    
Vlan27                 10.27.3.254     YES NVRAM  up                    down    
Vlan28                 10.28.3.254     YES NVRAM  up                    down    
Vlan32                 10.32.3.254     YES NVRAM  up                    down    
Vlan33                 10.33.3.254     YES NVRAM  up                    down    
Vlan34                 10.34.3.254     YES NVRAM  up                    down    
Vlan39                 10.39.3.254     YES NVRAM  up                    down    
Vlan40                 10.40.3.254     YES NVRAM  up                    down    
Vlan41                 10.41.3.254     YES NVRAM  up                    down    
Vlan42                 10.42.3.254     YES NVRAM  up                    down    
Vlan43                 10.43.3.254     YES NVRAM  up                    down    
Vlan100                10.100.3.254    YES NVRAM  up                    down    
Vlan101                10.101.3.254    YES NVRAM  up                    down    
Vlan127                10.127.3.254    YES NVRAM  up                    down    
GigabitEthernet1/0/1   unassigned      YES unset  down                  down    
GigabitEthernet1/0/2   unassigned      YES unset  down                  down    
GigabitEthernet1/0/3   unassigned      YES unset  down                  down    
GigabitEthernet1/0/4   unassigned      YES unset  down                  down    
GigabitEthernet1/0/5   unassigned      YES unset  down                  down    
GigabitEthernet1/0/6   unassigned      YES unset  down                  down    
GigabitEthernet1/0/7   unassigned      YES unset  down                  down    
GigabitEthernet1/0/8   unassigned      YES unset  down                  down    
GigabitEthernet1/0/9   unassigned      YES unset  down                  down    
GigabitEthernet1/0/10  unassigned      YES unset  down                  down    
GigabitEthernet1/0/11  unassigned      YES unset  down                  down    
GigabitEthernet1/0/12  unassigned      YES unset  down                  down    
GigabitEthernet1/0/13  unassigned      YES unset  down                  down    
GigabitEthernet1/0/14  192.168.42.167  YES DHCP   up                    up      
GigabitEthernet1/0/15  unassigned      YES unset  down                  down    
GigabitEthernet1/0/16  unassigned      YES unset  down                  down    
Te1/0/1                unassigned      YES unset  down                  down    
Te1/0/2                unassigned      YES unset  down                  down    
Loopback0              10.127.0.3      YES NVRAM  up                    up      
0
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

Are we done yet ? Pretty much. However, in our simple retry mechanism we have created a logic
error - if for some reason there is 9 retries, then we do not necessarily know that an error even
happened, other than seeing the message.

But this is a topic for the next post.

Hope you enjoyed this one.

If you like, you can grab a copy of the code repository at https://github.com/ayourtch/ts-netops-simple-ssh
and follow along.


Oh, the compiler warning that we dragged along all this time...
The example code did not take care that the function can return an error.
For this example neither do we, but we can do it in such a way that will
keep our shortcut visible and as well will clearly signal if it is
a problematic idea:

```
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git diff
diff --git a/src/main.rs b/src/main.rs
index fcdc1a1..327443a 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -26,6 +26,6 @@ fn main() {
         result = channel.read_to_string(&mut s);
     }
     println!("{}", s);
-    channel.wait_close();
+    channel.wait_close().unwrap();
     println!("{}", channel.exit_status().unwrap());
 }
ubuntu@ts-netops:~/ts-netops-simple-ssh$ cargo build
   Compiling ts-netops-simple-ssh v0.1.0 (/home/ubuntu/ts-netops-simple-ssh)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
ubuntu@ts-netops:~/ts-netops-simple-ssh$ git commit -a -m "Make the warning go away, in a way that will expose failures"
[master 8f5e8b2] Make the warning go away, in a way that will expose failures
 Date: Fri May 15 22:27:15 2020 +0000
 1 file changed, 1 insertion(+), 1 deletion(-)
ubuntu@ts-netops:~/ts-netops-simple-ssh$ 
```

